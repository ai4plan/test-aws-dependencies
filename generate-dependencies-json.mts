import { renderGraphFromSource } from "graphviz-cli";
import * as fs from "node:fs";

//--------------------------------------------------------------------------------------------------
function getOrCreateInMap<K, V>(map: Map<K, V>, k: K, ctr: () => V): V {
  const existing = map.get(k);
  if (existing) {
    return existing;
  }
  const created = ctr();
  map.set(k, created);
  return created;
}

type MultiOutputEntry = Record<string, string[] | boolean>;
type OutputEntry = string | MultiOutputEntry;

type NpmLsNode = {
  version: string;
  dependencies: { [dep_name: string]: NpmLsNode };
};

//--------------------------------------------------------------------------------------------------
function generate_dependencies_json(
  inputAbsPath: string,
  outputAbsPath: string,
  singleVersionMode: "with_parents" | "without_parents"
) {
  const json = fs.readFileSync(inputAbsPath, "utf8");
  const root = JSON.parse(json) as NpmLsNode;

  // walk recursively the json tree generated by `npm ls` and init dep_entries
  const dep_entries = new Map<string, Map<string, string[]>>();

  function walk(parent: NpmLsNode, parent_path: string) {
    if (!parent || !parent.dependencies) {
      return;
    }
    for (const dep_name of Object.keys(parent.dependencies)) {
      const dep_obj = parent.dependencies[dep_name];
      const dep_version = dep_obj.version;
      const dep_name_version = `${dep_name}@${dep_version}`;
      const dep_path = parent_path
        ? `${parent_path} > ${dep_name_version}`
        : dep_name_version;

      const dep_entry = getOrCreateInMap(
        dep_entries,
        dep_name,
        () => new Map<string, string[]>()
      );
      const dep_versions = getOrCreateInMap(
        dep_entry,
        dep_version,
        () => [] as string[]
      );
      dep_versions.push(parent_path);

      walk(dep_obj, dep_path);
    }
  }
  walk(root, "");

  const dep_names = Array.from(dep_entries.keys()).sort();

  const outputs = {} as Record<string, OutputEntry>;

  for (const dep_name of dep_names) {
    const dep_entry = dep_entries.get(dep_name)!;
    const dep_versions = Array.from(dep_entry.keys()).sort();

    // when there is a single version, we can
    // - either simply put the version string
    // - or write the parent_paths for this single version so that we understand what pulled it in
    if (dep_versions.length === 1 && singleVersionMode === "without_parents") {
      const dep_version = dep_versions[0];
      outputs[dep_name] = dep_version;
    } else {
      const multi = {} as MultiOutputEntry;

      if (dep_versions.length > 1) {
        multi["_multiple_versions"] = true; // makes it easier to spot multiple_versions in the output json
      }
      for (const dep_version of dep_versions) {
        const parent_paths = dep_entry.get(dep_version)!.sort(); // lexical sort is good enough
        multi[dep_version] = parent_paths;
      }
      outputs[dep_name] = multi;
    }
  }

  console.log(`Writing ${outputAbsPath}`);
  fs.writeFileSync(outputAbsPath, JSON.stringify(outputs, null, 2));
}

function addToGraph(
  graph: Map<string, Set<string>>,
  parent: string,
  child: string
): void {
  getOrCreateInMap(graph, parent, () => new Set<string>()).add(child); // prettier-ignore
  getOrCreateInMap(graph, child, () => new Set<string>());
}

//--------------------------------------------------------------------------------------------------
async function generate_dependencies_svg(
  inputAbsPath: string,
  outputAbsPath: string,
  filter_parent: (parent: string) => boolean,
  filter_child: (child: string) => boolean
) {
  const json = fs.readFileSync(inputAbsPath, "utf8");
  const root = JSON.parse(json) as NpmLsNode;

  //---------------------------------------------------------
  // walk recursively the json tree generated by `npm ls` -> dot_edges: 'parent,child'
  const dot_edges_set = new Set<string>();

  function walk(parent_obj: NpmLsNode, parent_name: string) {
    if (!parent_obj.dependencies) {
      return;
    }

    const dep_names = Object.keys(parent_obj.dependencies);
    for (const dep_name of dep_names) {
      const dot_edge = `${parent_name},${dep_name}`;
      dot_edges_set.add(dot_edge);

      const dep_obj = parent_obj.dependencies[dep_name];
      walk(dep_obj, dep_name);
    }
  }
  walk(root, "root");

  //---------------------------------------------------------
  // dot_edges_set -> graph
  const complete_graph = new Map<string, Set<string>>();
  const filtered_graph = new Map<string, Set<string>>();
  for (const dot_edge of dot_edges_set) {
    const [parent, child] = dot_edge.split(",");
    addToGraph(complete_graph, parent, child);
    if (filter_parent(parent) && filter_child(child)) {
      addToGraph(filtered_graph, parent, child);
    }
  }

  //---------------------------------------------------------
  // dot_edges_arr -> dot_content
  const dot_lines = [] as string[];
  dot_lines.push("digraph G {");
  dot_lines.push(` rankdir="LR";`);
  dot_lines.push(` node [shape=rect, style=rounded];`);

  for (const [parent, children] of filtered_graph) {
    // if ZERO dependencies in the complete graph, it's a dummy node, give it a different color
    if (complete_graph.get(parent)!.size === 0) {
      dot_lines.push(`"${parent}" [shape=rect, style="rounded,filled", fillcolor="#ffcccc"];`); // prettier-ignore
    } else {
      //dot_lines.push(`"${parent}";`); // COMMENTED BECAUSE NOT NECESSARY
      dot_lines.push(`"${parent}" -> { ${Array.from(children).map((v) => `"${v}"`).join(" ")} };`); // prettier-ignore
    }
  }

  dot_lines.push("}");
  const dot_content = dot_lines.join("\n");
  fs.writeFileSync(outputAbsPath + ".dot", dot_content);

  //---------------------------------------------------------
  // dot_content -> svg_content
  const svg_content = await renderGraphFromSource(
    { input: dot_content },
    { format: "svg" }
  );

  //---------------------------------------------------------
  // svg_content -> file
  console.log(`Writing ${outputAbsPath}`);
  fs.writeFileSync(outputAbsPath, svg_content);
}

//--------------------------------------------------------------------------------------------------
const folder = process.argv[2];
if (!folder) {
  console.error("Usage: node generate-dependencies-json.mjs <folder>");
  process.exit(1);
}

const folderAbsDir = `${import.meta.dirname}/${folder}`;

generate_dependencies_json(
  `${folderAbsDir}/npm-ls-all.json`,
  `${folderAbsDir}/dependencies-all.json`,
  "without_parents"
);

generate_dependencies_json(
  `${folderAbsDir}/npm-ls-all.json`,
  `${folderAbsDir}/dependencies-all-parents.json`,
  "with_parents"
);

// COMMENTED OUT BECAUSE NOT INTERESTING
// generate_dependencies_json(
//   `${folderAbsDir}/npm-ls-1.json`,
//   `${folderAbsDir}/dependencies-1.json`,
//   "without_parents"
// );

// COMMENTED OUT BECAUSE NOT INTERESTING
// generate_dependencies_svg(
//   `${folderAbsDir}/npm-ls-1.json`,
//   `${folderAbsDir}/dependencies-1.svg`,
//   (parent) => parent.includes("aws-amplify") || parent === "root",
//   (child) => child.includes("aws-amplify") && child !== "@aws-amplify/core"
// );

await generate_dependencies_svg(
  `${folderAbsDir}/npm-ls-all.json`,
  `${folderAbsDir}/dependencies-all.svg`,
  (parent) => parent.includes("aws-amplify") || parent === "root",
  (child) => child.includes("aws-amplify") && child !== "@aws-amplify/core"
);
